import joblib
import numpy as np
import pandas as pd
from typing import List, Dict, Any
from prod.StaticAnalyzer import StaticAnalyzer, generate_feature_vector
from prod.CodeReader import CodeReader

class VulnerabilityReportGenerator:
    def __init__(self, severity_model_path: str, confidence_model_path: str, scaler_path: str):
        """
        Initialize the report generator by loading the trained severity and confidence models
        along with the feature scaler.
        """
        self.severity_model = joblib.load(severity_model_path)
        self.confidence_model = joblib.load(confidence_model_path)
        self.scaler = joblib.load(scaler_path)
        self.reader = CodeReader(extensions=[
            ".py",
            ".cpp", ".cc", ".cxx", ".c++",
            ".c",
            ".java",
            ".cs",
            ".js",
            ".go",
            ".vb",
            ".sql",
            ".php",
            ".rs",
            ".ts"
        ])

    def analyze_path(self, target_path: str) -> List[Dict[str, Any]]:
        """
        Perform static analysis on all source files in the given path and generate vulnerability reports.

        :param target_path: Path to a source file or directory containing source files.
        :return: A list of dictionaries containing vulnerability reports.
        """
        files = self.reader.read_files(target_path)
        all_reports = []

        for file_path, code in files:
            analyzer = StaticAnalyzer()
            vulnerabilities = analyzer.analyze(code)

            if vulnerabilities and "error" in vulnerabilities[0]:
                all_reports.append({
                    "error": vulnerabilities[0].get("error")
                })
                return all_reports

            for vuln in vulnerabilities:
                # Generate feature vector for the individual vulnerability
                features = generate_feature_vector([vuln])
                X = pd.DataFrame([features])
                X_scaled = self.scaler.transform(X)

                # Predict severity using classification model
                severity_pred = self.severity_model.predict(X_scaled)[0]

                # Predict confidence using regression model
                confidence = round(float(self.confidence_model.predict(X_scaled)[0]), 2)

                # Build the report entry
                all_reports.append({
                    "problematic_function": vuln.get("function", "--"),
                    "problematic_variable": vuln.get("variable", "--"),
                    "file": file_path,
                    "line": vuln.get("line", "?"),
                    "issue": vuln.get("type", "--"),
                    "severity": severity_pred,
                    "confidence": confidence,
                    "suggested_fix": self._suggest_fix(vuln.get("type", ""))
                })

        return all_reports

    def _suggest_fix(self, issue_type: str) -> str:
        """
        Provide a fix suggestion based on the type of vulnerability.

        :param issue_type: The type of the detected issue.
        :return: A string describing a possible fix or mitigation.
        """
        suggestions = {
            "Dangerous Dynamic SQL Query": "Use parameterized queries instead of string concatenation.",
            "Generally Dangerous Function Call": "Avoid calling dangerous calls; use safer alternatives.",
            "Tainted File Access (open)": "Validate file paths to avoid path traversal.",
            "Unsafe Deserialization": "Avoid pickle; use safe formats like JSON.",
            "Use of Uninitialized Variable": "Initialize variables before use.",
        }
        return suggestions.get(issue_type, "Review the code and apply standard security practices.")
