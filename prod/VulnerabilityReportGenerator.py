import joblib
import numpy as np
from typing import List, Dict, Any
from prod.StaticAnalyzer import StaticAnalyzer, generate_feature_vector
from prod.CodeReader import CodeReader

class VulnerabilityReportGenerator:
    def __init__(self, severity_model_path: str, confidence_model_path: str, scaler_path: str):
        """
        Initialize the report generator with trained models and scaler.
        """
        self.severity_model = joblib.load(severity_model_path)
        self.confidence_model = joblib.load(confidence_model_path)
        self.scaler = joblib.load(scaler_path)
        self.reader = CodeReader(extensions=[".py", ".java"])

    def analyze_path(self, target_path: str) -> List[Dict[str, Any]]:
        """
        Analyze source code and return a structured vulnerability report.

        :param target_path: File or directory to analyze.
        :return: List of structured report entries.
        """
        files = self.reader.read_files(target_path)
        all_reports = []

        for file_path, code in files:
            analyzer = StaticAnalyzer()
            vulnerabilities = analyzer.analyze(code)

            for vuln in vulnerabilities:
                features = generate_feature_vector([vuln])
                X = np.array([list(features.values())])
                X_scaled = self.scaler.transform(X)

                severity_pred = self.severity_model.predict(X_scaled)[0]
                confidence_pred = self.confidence_model.predict_proba(X_scaled)[0]
                severity = ["Low", "Medium", "High"][severity_pred]
                confidence = round(float(max(confidence_pred)), 2)

                all_reports.append({
                    "file": file_path,
                    "line": vuln.get("line", "?"),
                    "issue": vuln.get("type", "Unknown issue"),
                    "severity": severity,
                    "confidence": confidence,
                    "code_snippet": "(context not available)",  # Optional enhancement: extract snippet
                    "suggested_fix": self._suggest_fix(vuln.get("type", ""))
                })

        return all_reports

    def _suggest_fix(self, issue_type: str) -> str:
        """
        Suggest a remediation based on vulnerability type.
        """
        suggestions = {
            "Dangerous Dynamic SQL Query": "Use parameterized queries instead of string concatenation.",
            "Generally Dangerous Function Call": "Avoid eval/exec; use safer alternatives.",
            "Tainted File Access (open)": "Validate file paths to avoid path traversal.",
            "Unsafe Deserialization": "Avoid pickle; use safe formats like JSON.",
            "Use of Uninitialized Variable": "Initialize variables before use.",
        }
        return suggestions.get(issue_type, "Review the code and apply standard security practices.")
