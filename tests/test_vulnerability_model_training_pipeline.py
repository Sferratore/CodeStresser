import os
import unittest
import pandas as pd
import joblib
from prod.VulnerabilityModelTrainingPipeline import VulnerabilityModelTrainingPipeline

class TestVulnerabilityModelTrainingPipeline(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        # Define test dataset (one vulnerability per row)
        cls.test_data_path = "test_training_data.csv"
        df = pd.DataFrame([
            {
                "generally_dangerous_calls": 1,
                "unprotected_critical_calls": 0,
                "tainted_input_in_dangerous_calls": 0,
                "tainted_param_source_calls": 0,
                "dangerous_dynamic_sql": 0,
                "tainted_flows": 0,
                "missing_error_handling": 0,
                "deep_control_nesting": 0,
                "uninitialized_variable_usage": 0,
                "tainted_file_access": 0,
                "unsafe_deserialization": 0,
                "buffer_overflow_risk": 0,
                "severity": 2,
                "confidence": 0.8
            },
            {
                "generally_dangerous_calls": 0,
                "unprotected_critical_calls": 1,
                "tainted_input_in_dangerous_calls": 0,
                "tainted_param_source_calls": 0,
                "dangerous_dynamic_sql": 0,
                "tainted_flows": 0,
                "missing_error_handling": 0,
                "deep_control_nesting": 0,
                "uninitialized_variable_usage": 0,
                "tainted_file_access": 0,
                "unsafe_deserialization": 0,
                "buffer_overflow_risk": 0,
                "severity": 3,
                "confidence": 0.6
            },
            {
                "generally_dangerous_calls": 0,
                "unprotected_critical_calls": 0,
                "tainted_input_in_dangerous_calls": 0,
                "tainted_param_source_calls": 0,
                "dangerous_dynamic_sql": 1,
                "tainted_flows": 0,
                "missing_error_handling": 0,
                "deep_control_nesting": 0,
                "uninitialized_variable_usage": 0,
                "tainted_file_access": 0,
                "unsafe_deserialization": 0,
                "buffer_overflow_risk": 0,
                "severity": 4,
                "confidence": 0.9
            }
        ])
        df.to_csv(cls.test_data_path, index=False)

        # Output model/scaler paths
        cls.severity_path = "test_severity.pkl"
        cls.confidence_path = "test_confidence.pkl"
        cls.scaler_path = "test_scaler.pkl"

        cls.pipeline = VulnerabilityModelTrainingPipeline(
            data_path=cls.test_data_path,
            model_severity_path=cls.severity_path,
            model_confidence_path=cls.confidence_path,
            scaler_path=cls.scaler_path
        )

    def test_pipeline_training_and_saving(self):
        self.pipeline.load_data()
        self.pipeline.preprocess()
        acc_sev, r2_conf = self.pipeline.train()

        self.assertGreaterEqual(acc_sev, 0.0)
        self.assertLessEqual(acc_sev, 1.0)
        self.assertGreaterEqual(r2_conf, 0.0)
        self.assertLessEqual(r2_conf, 1.0)

        self.pipeline.save_models()

        self.assertTrue(os.path.exists(self.severity_path))
        self.assertTrue(os.path.exists(self.confidence_path))
        self.assertTrue(os.path.exists(self.scaler_path))

        model_sev = joblib.load(self.severity_path)
        model_conf = joblib.load(self.confidence_path)
        scaler = joblib.load(self.scaler_path)

        self.assertIsNotNone(model_sev)
        self.assertIsNotNone(model_conf)
        self.assertIsNotNone(scaler)

    @classmethod
    def tearDownClass(cls):
        for f in [cls.test_data_path, cls.severity_path, cls.confidence_path, cls.scaler_path]:
            if os.path.exists(f):
                os.remove(f)

if __name__ == "__main__":
    unittest.main()
