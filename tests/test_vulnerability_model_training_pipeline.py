import os
import unittest
import pandas as pd
import joblib
from prod.VulnerabilityModelTrainingPipeline import VulnerabilityModelTrainingPipeline

class TestVulnerabilityModelTrainingPipeline(unittest.TestCase):
    def setUp(self):
        """
        Set up the model paths and pipeline using the existing training dataset.
        """
        self.test_data_path = "../training_data/training_data.csv"

        self.severity_path = "../model/severity_model.pkl"
        self.confidence_path = "../model/confidence_model.pkl"
        self.scaler_path = "../model/scaler.pkl"

        self.pipeline = VulnerabilityModelTrainingPipeline(
            data_path=self.test_data_path,
            model_severity_path=self.severity_path,
            model_confidence_path=self.confidence_path,
            scaler_path=self.scaler_path
        )

    def tearDown(self):
        """
        Remove generated model and scaler files after each test.
        """
        for path in [self.severity_path, self.confidence_path, self.scaler_path]:
            if os.path.exists(path):
                os.remove(path)

    def test_pipeline_training_and_saving(self):
        """
        Test the end-to-end training and saving of the models and scaler.
        """
        self.pipeline.load_data()
        self.pipeline.preprocess()
        acc_sev, r2_conf = self.pipeline.train()

        self.assertGreaterEqual(acc_sev, 0.0)
        self.assertLessEqual(acc_sev, 1.0)
        self.assertGreaterEqual(r2_conf, 0.0)
        self.assertLessEqual(r2_conf, 1.0)

        self.pipeline.save_models()

        self.assertTrue(os.path.exists(self.severity_path))
        self.assertTrue(os.path.exists(self.confidence_path))
        self.assertTrue(os.path.exists(self.scaler_path))

        model_sev = joblib.load(self.severity_path)
        model_conf = joblib.load(self.confidence_path)
        scaler = joblib.load(self.scaler_path)

        self.assertIsNotNone(model_sev)
        self.assertIsNotNone(model_conf)
        self.assertIsNotNone(scaler)

    def test_empty_dataset(self):
        """
        Verify that an empty dataset raises an error.
        """
        empty_path = "empty.csv"
        pd.DataFrame().to_csv(empty_path, index=False)

        pipeline = VulnerabilityModelTrainingPipeline(data_path=empty_path)
        with self.assertRaises(Exception):
            pipeline.load_data()

        os.remove(empty_path)

    def test_missing_columns(self):
        """
        Verify that missing required columns triggers an error.
        """
        incomplete_path = "incomplete.csv"
        df = pd.DataFrame([{"generally_dangerous_calls": 1, "confidence": 0.5}])
        df.to_csv(incomplete_path, index=False)

        pipeline = VulnerabilityModelTrainingPipeline(data_path=incomplete_path)
        with self.assertRaises(KeyError):
            pipeline.load_data()

        os.remove(incomplete_path)

    def test_extreme_values(self):
        """
        Test if the pipeline can handle extreme but valid numerical values.
        """
        extreme_path = "extreme.csv"
        df = pd.DataFrame([
            {
                "generally_dangerous_calls": 999,
                "unprotected_critical_calls": 0,
                "tainted_input_in_dangerous_calls": 0,
                "tainted_param_source_calls": 0,
                "dangerous_dynamic_sql": 0,
                "tainted_flows": 0,
                "missing_error_handling": 0,
                "deep_control_nesting": 0,
                "uninitialized_variable_usage": 0,
                "tainted_file_access": 0,
                "unsafe_deserialization": 0,
                "buffer_overflow_risk": 0,
                "severity": "Critical",
                "confidence": 1.0
            },
            {
                "generally_dangerous_calls": 0,
                "unprotected_critical_calls": 0,
                "tainted_input_in_dangerous_calls": 1,
                "tainted_param_source_calls": 0,
                "dangerous_dynamic_sql": 0,
                "tainted_flows": 0,
                "missing_error_handling": 0,
                "deep_control_nesting": 0,
                "uninitialized_variable_usage": 0,
                "tainted_file_access": 0,
                "unsafe_deserialization": 0,
                "buffer_overflow_risk": 1,
                "severity": "High",
                "confidence": 0.95
            }
        ])
        df.to_csv(extreme_path, index=False)

        pipeline = VulnerabilityModelTrainingPipeline(
            data_path=extreme_path,
            model_severity_path=self.severity_path,
            model_confidence_path=self.confidence_path,
            scaler_path=self.scaler_path
        )

        pipeline.run_pipeline()

        self.assertTrue(os.path.exists(self.severity_path))
        self.assertTrue(os.path.exists(self.confidence_path))
        self.assertTrue(os.path.exists(self.scaler_path))

        os.remove(extreme_path)

    def test_invalid_values(self):
        """
        Test if the pipeline raises an error when encountering non-numeric feature values.
        """
        invalid_path = "invalid.csv"
        df = pd.DataFrame([
            {
                "generally_dangerous_calls": "invalid",
                "unprotected_critical_calls": 0,
                "tainted_input_in_dangerous_calls": 0,
                "tainted_param_source_calls": 0,
                "dangerous_dynamic_sql": 0,
                "tainted_flows": 0,
                "missing_error_handling": 0,
                "deep_control_nesting": 0,
                "uninitialized_variable_usage": 0,
                "tainted_file_access": 0,
                "unsafe_deserialization": 0,
                "buffer_overflow_risk": 0,
                "severity": "Low",
                "confidence": 0.5
            }
        ])
        df.to_csv(invalid_path, index=False)

        pipeline = VulnerabilityModelTrainingPipeline(
            data_path=invalid_path,
            model_severity_path=self.severity_path,
            model_confidence_path=self.confidence_path,
            scaler_path=self.scaler_path
        )

        with self.assertRaises(ValueError):
            pipeline.run_pipeline()

        os.remove(invalid_path)


if __name__ == "__main__":
    unittest.main()
